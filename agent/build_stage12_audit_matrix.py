"""Build Stage 12 module/class/method audit matrix."""

from __future__ import annotations

import ast
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable


REPO_ROOT = Path(__file__).resolve().parents[1]
TARGET_DIRS = ("core", "utils", "agent", "config", "web_prototype")
OUTPUT_FILE = REPO_ROOT / "doc" / "governance" / "stage12_module_audit_matrix.md"
SKIP_PARTS = {"__pycache__", ".venv", "venv"}


@dataclass(frozen=True)
class Item:
    """Single matrix entry for one discovered symbol."""

    kind: str
    qualified_name: str


def _iter_py_files() -> list[Path]:
    """Collect Python source files under target dirs excluding virtualenv/cache paths."""
    files: list[Path] = []
    for root_name in TARGET_DIRS:
        root = REPO_ROOT / root_name
        if not root.exists():
            continue
        for path in sorted(root.rglob("*.py")):
            if SKIP_PARTS.intersection(path.parts):
                continue
            files.append(path)
    return files


def _module_name(path: Path) -> str:
    """Convert repository-relative path to dotted module name."""
    rel = path.relative_to(REPO_ROOT)
    return str(rel.with_suffix("")).replace("\\", ".").replace("/", ".")


def _collect_items(path: Path) -> list[Item]:
    """Parse one file and extract module-level functions/classes/methods."""
    source = path.read_text(encoding="utf-8-sig")
    try:
        tree = ast.parse(source, filename=str(path))
    except SyntaxError:
        module = _module_name(path)
        return [Item(kind="parse_error", qualified_name=module)]
    items: list[Item] = []
    module = _module_name(path)

    for node in tree.body:
        if isinstance(node, ast.ClassDef):
            cls_name = f"{module}.{node.name}"
            items.append(Item(kind="class", qualified_name=cls_name))
            for sub in node.body:
                if isinstance(sub, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    items.append(
                        Item(
                            kind="method",
                            qualified_name=f"{cls_name}.{sub.name}",
                        )
                    )
        elif isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            items.append(Item(kind="function", qualified_name=f"{module}.{node.name}"))
    return items


def _iter_render_rows(items_by_module: dict[str, list[Item]]) -> Iterable[str]:
    """Yield markdown table rows for matrix items."""
    for module in sorted(items_by_module):
        for item in items_by_module[module]:
            yield f"| `{module}` | {item.kind} | `{item.qualified_name}` | todo | todo | todo | |"


def _render(items_by_module: dict[str, list[Item]]) -> str:
    """Render markdown matrix content for discovered repository symbols."""
    lines: list[str] = []
    lines.append("# Stage 12 Module Audit Matrix")
    lines.append("")
    lines.append("Generated by `agent/build_stage12_audit_matrix.py`.")
    lines.append("Status fields are initialized as `todo` for manual review.")
    lines.append("")
    lines.append("| module | item kind | item | typing | docstring | readability | notes |")
    lines.append("|---|---|---|---|---|---|---|")
    lines.extend(_iter_render_rows(items_by_module))
    return "\n".join(lines) + "\n"


def main() -> int:
    items_by_module: dict[str, list[Item]] = {}
    for path in _iter_py_files():
        module = _module_name(path)
        items = _collect_items(path)
        if items:
            items_by_module[module] = items
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_FILE.write_text(_render(items_by_module), encoding="utf-8")
    print(f"audit_matrix_file={OUTPUT_FILE}")
    print(f"modules_count={len(items_by_module)}")
    print(f"items_count={sum(len(v) for v in items_by_module.values())}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
